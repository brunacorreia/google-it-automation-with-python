# Using Python to Interact with the Operating System 
This course will teach how to use Python to perform system administration tasks and interact with a computer’s operating system. For some exercises the application called Qwiklabs is going to be used in a remote Linux virtual machine.
# Week 2 - Managing Files with Python
## Learning Objectives:
- Understand how to read, write, and iterate through files
- Utilize the concept of managing files by moving, deleting, and renaming files
- Understand how to create directories and navigate through directories
- Define what CSV files are and be able to read from them
- Understand how to write and make edits to CSV files within directories
### Vocabulary Notes:
- **Absolute Path:** is a full path to the resource in the file system. We call it absolute path because it doesn't matter where in the file system our script is running, the absolute path will always lead us to the resource.
Example: 
→ On windows, the absolute path to the folder for the user Jordan would be: C:\Users\Jordan
→ On a Linux computer, the absolute path to the equivalent directory would be /home/jordan
- **Relative Paths:** use only a portion of a path to show where the resource is located in relation to the current working directory. Relative paths are a shortcut that you can use so you don't have to write out the full file path. But keep in mind, they only makes sense relative to the current location.
Example: 
→ If we list the contents of the directory examples, we'll get different outputs depending on what the current directory is. If our current directory is /home/jordan, we'll get the contents of /home/jordan/examples
→ But if the current directory is /user/share/doc/python3, we'll get the contents of /user/share/doc/python3/examples
- **File descriptor:** a token, generated by the OS that allows programs to do more operations with the file. In Python, this file descriptor is stored as an attribute of the files object. The file object gives us a bunch of methods that we can use to operate with the file. Now, with this file object, we can read the contents of the file and print them to the screen.
- **Parsing:** analyzing a file's content to correctly structure the data

### Reading Files

---

- file = open("spider.txt") → to open the file spider.txt
- print(file.readline()) → the readline method let us read a single line of the file
- print(file.read()) → read the file from the beginning (or where the last readline stopped) to the end
- file.close() → it is importante to close every file after using it. The WITH fuction might help us closing all the files forgotten

→ with block → open-use-close automatically:
- with open("spider.txt") as file:

         print(file.readline())

    - with open("spider.txt") as file:

    - Escape sequences:
        - Like backslash (\n)
        - backslash t (\t)

    ATENTION: To big text files, it is better to read it line by like (using file.readline) than to store the text in a variable

    ### Writing files

    Modes:

    - r (read-only mode)
    - w(writing-only mode)→ you cant read the file
    - a(appending content to the end of an exhisting file)
    - r+(read-write mode)→ you can both read contents and overwrite it

    ### If you open a file for writing and the file already exists, the old contents will be deleted as soon as the file is opened.

    ### Double-check before opening every file:

    For example, if you're generating a log file of events that your program came across, you probably want to open the file using append, a mode. Opening it in write, w mode, would mean you'd write over any previous entries in that file, and that's not a good idea for a log file. Or if you're generating a report and wants to write it out to a new file using the write, w mode, you probably want to check if the file exists, to avoid losing any previous contents.

    ## Working with files
    - os.remove("novel.txt") → remove function: to remove a file
    - os.rename("old name", "new name") → to change the files name
    ## OS path submodules:

    - os.path.exists("finished_masterpiece.txt") → returns TRUE or FILE
    - os.path.getsize("spide.txt") → to check how big a size is
    - os.path.getmtime("spider.txt")→ to get the last ime the time was modified. Give us the timestamp: the seconds since january 1st 1970 (for unix fiesystem)
    - datetime / .fromtimestamp
    - isfile() → determine if a file exists

    Ex:

    import os

    file= "file.dat"

    if os.path.isfile(file):

    print(os.path.isfile(file))

    print(os.path.getsize(file))

    else:

    print(os.path.isfile(file))

    print("File not found")

    - abspath fuction → to find exactly the place where the file is to work with it in our script

    Ex.: os.path.abspath("spider.txt")

    ## Directories

    - getcwd method → find file location
    - mkdir → to create a directory
    - chdir → change directories in your program
    - os.rmdir("newer_dir") → will only work if the directory is empty, without any files

    ### How to discover the contents of a directory

    - os.listdir("website")
    - os.path.isdir(fullname)
    - os.path.join function: It creates a string containing cross-platform concatenated directories

    ## Reading and Writing CSV Files

    ### What is a CS file?

    CSV = Comma Separated Values → very common data format used to store data as segment of text separated by commas

    - These files are stored in a plaintext
    - Each line in a CSV file generally represents a single data record
    - If we have data in a format we understand, then we have what we need to parse the information from the file. What does parsing really mean? **Parsing** → Using rules to understand a file or datastream as structured data. If we know the format of the data, we can separate it into understandable parts.

    This format (CSV) lets us easily store and retrieve information that we might need for our scripts like employees in our company or computer's inner network. In my job as a system administrator, I create CSV files when I want to convert the output of a command into a format that will be easier to parse later on.

    - For example, the **df** command prints the currently used disk space in a format that's easy to read by human eyes. By turning the info into a CSV makes it much easier to work with the data in my scripts.
    - It can actually be helpful to think of a CSV file like it's a spreadsheet, where each line corresponds to a row and each comma separated field corresponds to a column.

    ### Reading CSV Files
    How to open and read a CSV file:

    1) import csv

    2) create a var to open file

    3) create a var to read file

    4) iterate through each line of the file 

    - 'unpacking the values': calling the variables after iterating to refer to the values

    ### Generating CSV files
    functions:
    - writerow → write one row at a time
    - writerows → write all rows together

    1) creating a list

    2) opening this file in writing mode

    3) use writerows method

    ### Reading and Writing CSV files with DICTIONARIES

    - dicReader → this reader turns each row of the data in a CSV file into a dictionary. We can then access the data by using the column names instead of the position in the row. DictReader() allows us to convert the data in a CSV file into a standard dictionary.
    - dicWriter → DictWriter() \ allows us to write data from a dictionary into a CSV file. What’s one parameter we must pass in order for DictWriter() to write our dictionary to CSV format? Answer: The fieldnames parameter of DictWriter() requires a list of keys

  
